# Лабораторная работа №2

## Цель работы

Изучить основы оптимизации и векторизации алгоритмов компьютерного зрения на базе процессорной системы ARM Cortex A57 MPCore + NEON. 

## Задание 

1.  Разработать программу на C++, реализующую задание в соответствии с 
вариантом двумя способами: без использования векторных 
инструкций и с ними.  
2.  Оценить следующие характеристики: 
    1. Зависимость производительности при изменении размера входных данных (размера изображения). 
    2. Зависимость производительности от уровня оптимизации (флаги -O0, -O1, -O2, -O3) для варианта без векторных инструкций. 
    3. Влияние ручной векторизации алгоритма на производительность. 

### Примечение:

Измерение скорости выполнения алгоритма должно быть выполнено 
несколько раз с последующим усреднением для минимизации влияния 
степени загруженности процессора другими процессами.

## Вариант

Нормирование (MINMAX) grayscale изображения (поиск минимума и максимума можно считать входными данными)

## Теоретическая база 

***Grayscale*** — цветовой режим изображений, которые отображаются в оттенках серого цвета, реализованные в виде таблицы с указанием яркости белого цвета для каждой точки.

***Нормирование*** - по формуле

## Описание разработанной системы

Было написано две функции - одна обычная, которая проходит линейно по каждому пикселю в картинке. И одна с исппользованием библиотеки `neon`

Для нормализации использовалась MINMAX, формула представлена на картинке

![img](https://www.oreilly.com/api/v2/epubs/9781788627306/files/assets/ffb3ac78-fd6f-4340-aa92-cde8ae0322d6.png)

В процессоре ARM NEON доступен 128-битный регистр, на который можно применять векторные инструкции SIMD.





Код обычной (линейной) функции нормализации изображения

```c++
void normalise_gray(const uint8_t* gray, uint8_t* normalised,\
 int num_pixels, uint8_t x_min, uint8_t x_max)
{
  for(int i=0; i<num_pixels; ++i) {
    float norm_val = (float)(gray[i] - x_min) / (float)(x_max - x_min);
    normalised[i] = norm_val * 255;
  }
}
```



А вот код с использованием возможностей neon - тут обрабатываются уже одновременно по 4 пикселя.

```c++
void normalise_gray_neon(const uint8_t* gray, uint8_t* normalised,\
  int num_pixels, uint8_t x_min, uint8_t x_max)
{
  num_pixels /= 8;
  float x_koef = (float)(x_max - x_min) * 255;

  float32x4_t x_mins = vdupq_n_f32(x_min);
  float32x4_t x_koefs = vdupq_n_f32(x_koef);

  for(int i=0; i<num_pixels; ++i, gray+=4, normalised+=4) {
    float tmp_pixels_4_f32[] = { (float)gray[0], (float)gray[1], (float)gray[2], (float)gray[3] };
    float32x4_t pixels_4 = vld1q_f32(tmp_pixels_4_f32);
    pixels_4 = vsubq_f32(pixels_4, x_mins);
    pixels_4 = vmulq_f32(pixels_4, x_koefs);
    float pixels_4_f32[] = {0.0, 0.0, 0.0, 0.0};
    vst1q_f32(pixels_4_f32, pixels_4);
    uint8_t pixels_4_u8[] = { (uint8_t)pixels_4_f32[0], (uint8_t)pixels_4_f32[1], (uint8_t)pixels_4_f32[2], (uint8_t)pixels_4_f32[3] };
  }
}
```

Мы также попытались использовать `f16x8_t` вместо `f32x4_t`, чтобы обрабатывать по 8 пикселей. Но видимо этот тип не поддерживается, т.к. код не удалось скомпилировать.



### Результаты

Далее представлены усредненные результаты за 5 прогонов, для минимизации влияния фоновых процессов.

С флагом оптимизации -O0

- Обычный алгоритм (средняя за 5 прогонов): 5963 мс

- Векторный алгоритм (средняя за 5 прогонов): 2227 мс



С флагом оптимизации -O1

- Обычный алгоритм (средняя за 5 прогонов): 1745 мс

- Векторный алгоритм (средняя за 5 прогонов): 447 мс



С флагом оптимизации -O2

- Обычный алгоритм (средняя за 5 прогонов): 1726 мс

- Векторный алгоритм (средняя за 5 прогонов): 310 мс



С флагом оптимизации -O0

- Обычный алгоритм (средняя за 5 прогонов): 1525 мс

- Векторный алгоритм (средняя за 5 прогонов): 315 мс



Векторный алгоритм во всех случаях превосходит обычный в несколько раз по скорости
